
/*

			常用方法：

			1、a << b = a * 2的b次幂			19 << 8 = 19 * 512 ，a 为负数时负号不变

			2、a >> b = a / 2的b次幂			72 >> 3 = 72 / 8 , 非整数时，只取整数位

			3、判断奇偶数，	a & 1 = 0 偶数		1010 & 0001 = 0000
							a & 1 = 1 奇数		0101 & 0001 = 0001

			4、判断一个正整数x是不是2的n次幂
				x = 512
				if ((x&(x - 1)) == 0 && x != 0){ true }

			5、用一个字节表示四个选项的16种组合
				0000 ：四个选项都为false，int值为0
				0010 ：第二个选项为true，int值为2
				1000 ：第四个选项为true，int值为8
				...

				获取目标值V的第n位的二进制值：res = (V >> n) & 1;
				设置目标值V的第n位的二进制值为a：V^=(V&(1<<n)) ^ (a<<n)

				//获取 val 第三位的二进制值 为 1
				int val = 2;
				int res = (val >> 2) & 1;

				//设置 val （2 : 0010）中第三位为 1 (6 : 0110)
				val ^= (val&(1 << 2)) ^ (1 << 2);

				注：从低位到高位算,从第0位开始算，示例在main()中


			6、交换两变量的值（感觉没啥卵用）
			void swap(int x , int y){
			 	x ^= y;
			  	y ^= x;
			   	x ^= y;
			   }


			   关于位运算

			   ~	取反：0变1，1变0
			   0000-0101 =>
			   1111-1010

			   &	与	：同时为1时为1，否则为0
			   0000-0101 &
			   0001-1100 =>
			   0001-0100

			   |	或	：任意为1则为1，全是0则为0
			   0000-0101 |
			   0001-1100 =>
			   0001-1101

			   ^	异或：只有 0 and 1 时为1，其它都为0
			   0000-0101 ^
			   0001-1100 =>
			   0001-1001

			   <<	左移 a = 9,b = 3 a<<b ,a左移b位,0补位
			   0000-1001 << 0000-0011
			   （000{0100-1)000}

			   >> 右移 a = -9,b = 3 a<<b ,a右移b位,用第一位补位
			   1000-1001 >> 0000-0011
			   {111(1-0001}001)

			   特性： int a,b;

			   1、a 取反(~)偶数次，还是 a          ~0101 = 1010 ， ~1010 = 0101
			   2、a 异或(^) b 偶数次，还是 a		 0101^0111 = 0010 , 0010^0111 = 0101
			   3、b = 0 时，a & b = 0				 0101 & 0000 = 0000
			   4、b = 1111-1111 时，a & b = a		 0101 & 1111 = 0101
			   5、b = 1111-1111 时，a | b = b		 0101 | 1111 = 1111
			   6、b = 0 时，a | b = a				 0101 | 0000 = 0101
			   7、b = 0 时，a ^ b = a				 0101 ^ 0000 = 0101
			   8、b = 1111-1111时，a ^ b = ~a		 0101 ^ 1111 = 1010

*/
#include <iostream>
using namespace std;

int main()
{
	//获取 val 第三位的二进制值 为 1
	int val = 2;
	int res = (val >> 2) & 1;

	//设置 val （2 : 0010）中第三位为 1 (6 : 0110)
	val ^= (val&(1 << 2)) ^ (1 << 2);

	return 0;
}